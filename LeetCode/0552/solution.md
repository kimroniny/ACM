暴力方法肯定是深搜, 当然肯定也超时. 主要是怎么从深搜想到动态规划, 毕竟动态规划就是深搜的优化版, 减少了很多已经计算过的搜索.

处理第 `i` 个字符的时候, 分别针对 `P` `A` `L` 三种字符单独判断.
- `P`: 可以直接加;
- `A`: 需要判断之前是否已经有 `A`, 因此这个状态需要一个状态来保存;
- `L`: 需要判断上一个字符是否是 `L`.

有一个状态表示当前是哪一个字符, 另一个状态表示之前是否有字符 'A', 则可得 `f[N][4][2]`.
- 一维: 第 `i` 个字符
- 二维: 
  - 0: `P`; 
  - 1: `A`; 
  - 2: `XL`, 即当前字符为 `L`, 但是上一个字符不是 `L`;
  - 3: `XLL`, 即当前字符为 `L`, 上一个字符也是 `L`, 但是上上个字符不是 `L`;
- 三维:
  - 0: 第 `i` 个字符之前没有字符 `A`;
  - 1: 第 `i` 个字符之前有字符 `A`;

